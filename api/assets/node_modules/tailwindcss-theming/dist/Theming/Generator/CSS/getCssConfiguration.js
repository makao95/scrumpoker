"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const ColorVariant_1 = require("../../Variant/ColorVariant");
const OpacityVariant_1 = require("../../Variant/OpacityVariant");
const getCssThemeName_1 = require("./getCssThemeName");
function getCssConfiguration(themes, config) {
    const defaultTheme = utils_1.getDefaultTheme(themes);
    const cssConfiguration = {};
    const variants = [];
    // Set themes
    themes.forEach(theme => {
        let thisThemeConfig = {};
        // Define colors
        theme.getColors().forEach(color => {
            thisThemeConfig[utils_1.getColorVariableName(color, config)] = utils_1.getColorCssVariableValue(color, config);
            variants.push(...theme.variantsOf(color.keyName));
            // Warn if color is not defined in default theme
            if (!defaultTheme.getColors().find(defaultThemeColor => defaultThemeColor.keyName === color.keyName)) {
                console.warn(`Color ${color.keyName} is not defined in the main theme and won't be available in Tailwind utilities.`);
            }
        });
        // Define variants
        variants.forEach(variant => {
            if (variant instanceof ColorVariant_1.ColorVariant) {
                thisThemeConfig[utils_1.getColorVariantVariableName(variant)] = utils_1.getColorVariantCssVariableValue(variant, config);
            }
            else if (variant instanceof OpacityVariant_1.OpacityVariant) {
                if (!config.hexadecimal) {
                    thisThemeConfig[utils_1.getOpacityVariantVariableName(variant)] = variant.opacity.toString();
                }
            }
            else {
                throw new Error(`Unknown variant type for '${variant.name}'.`);
            }
        });
        // Define custom properties
        theme.getCustomProperties().forEach(property => {
            thisThemeConfig[utils_1.getCustomPropertyVariableName(property)] = property.computed;
        });
        // Theme is not under a preference scheme, so we put it in the css and rename it to
        // :root if needed
        if (!theme.hasScheme()) {
            cssConfiguration[getCssThemeName_1.getCssThemeName(theme, config)] = thisThemeConfig;
        }
        // Theme needs to be assignable, so we keep a version outside of the media queries and
        // we don't rename it to :root if it's the default theme
        if (theme.isAssignable()) {
            cssConfiguration[getCssThemeName_1.getCssThemeName(theme, config, true)] = thisThemeConfig;
        }
        // Theme is under a media query, so we set it under that media query.
        if (theme.hasScheme()) {
            let query = `@media (prefers-color-scheme: ${theme.getScheme()})`;
            cssConfiguration[query] = cssConfiguration[query] || {};
            cssConfiguration[query][getCssThemeName_1.getCssThemeName(theme, config)] = thisThemeConfig;
        }
    });
    return cssConfiguration;
}
exports.getCssConfiguration = getCssConfiguration;
