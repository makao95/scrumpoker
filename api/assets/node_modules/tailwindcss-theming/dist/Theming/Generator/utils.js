"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ThemeScheme_1 = require("../Theme/ThemeScheme");
/**
 * Get the default theme out of an array of themes.
 *
 * @export
 * @param {Theme[]} themes
 * @returns {Theme}
 */
function getDefaultTheme(themes) {
    let defaultsWithoutScheme = themes.filter(theme => theme.isDefault() && !theme.hasScheme());
    let defaultsDarkScheme = themes.filter(theme => theme.isDefault() && theme.getScheme() === ThemeScheme_1.ThemeScheme.Dark);
    let defaultsLightScheme = themes.filter(theme => theme.isDefault() && theme.getScheme() === ThemeScheme_1.ThemeScheme.Light);
    let unamed = themes.filter(theme => !theme.hasName() && !theme.isDefault());
    if (unamed.length > 0) {
        throw new Error(`Some themes don't have names.`);
    }
    if (defaultsWithoutScheme.length === 0) {
        throw new Error('There is no default theme.');
    }
    if (defaultsWithoutScheme.length > 1) {
        throw new Error('There are multiple default themes.');
    }
    if (defaultsDarkScheme.length > 1 || defaultsLightScheme.length > 1) {
        throw new Error('There are multiple default themes for a scheme.');
    }
    return defaultsWithoutScheme[0];
}
exports.getDefaultTheme = getDefaultTheme;
/**
 * Get the name of the CSS variable for given color.
 *
 * @export
 * @param {Color} color
 * @param {Configuration} config
 * @returns {string}
 */
function getColorVariableName(color, config) {
    return `--${[config.colorVariablePrefix, color.keyName].filter(Boolean).join('-')}`;
}
exports.getColorVariableName = getColorVariableName;
/**
 * Get the name of the CSS variable for a color variant.
 *
 * @export
 * @param {ColorVariant} variant
 * @param {Configuration} config
 * @returns {string}
 */
function getColorVariantVariableName(variant) {
    return `--color-variant-${getFormattedVariantScope(variant)}${variant.name}`;
}
exports.getColorVariantVariableName = getColorVariantVariableName;
/**
 * Get a string with the variant scope.
 *
 * @param variant
 */
function getFormattedVariantScope(variant) {
    const scope = getVariantScope(variant);
    return scope ? `${scope}-` : '';
}
exports.getFormattedVariantScope = getFormattedVariantScope;
/**
 * Get the name of the variant's target or null.
 *
 * @param variant
 */
function getVariantScope(variant) {
    return variant.colors.length === 1 ? variant.colors[0] : null;
}
exports.getVariantScope = getVariantScope;
/**
 * Get the name of the CSS variable for an opacity variant.
 *
 * @export
 * @param {ColorVariant} variant
 * @param {Configuration} config
 * @returns {string}
 */
function getOpacityVariantVariableName(variant) {
    return `--opacity-variant-${getFormattedVariantScope(variant)}${variant.name}`;
}
exports.getOpacityVariantVariableName = getOpacityVariantVariableName;
/**
 * Get the name of the CSS custom property.
 *
 * @export
 * @param {CustomProperty} property
 * @returns {string}
 */
function getCustomPropertyVariableName(property) {
    return `--${property.getPrefix()}${getPascalCase(property.getName())}`;
}
exports.getCustomPropertyVariableName = getCustomPropertyVariableName;
/**
 * Gets the CSS value for a color variant.
 *
 * @export
 * @param {ColorVariant} variant
 * @param {Configuration} config
 * @returns {string}
 */
function getColorVariantCssConfiguration(variant, config) {
    const variable = `var(${getColorVariantVariableName(variant)})`;
    if (config.hexadecimal) {
        return variable;
    }
    else if (variant.color.a !== 1) {
        return `rgba(${variable})`;
    }
    else {
        return `rgb(${variable})`;
    }
}
exports.getColorVariantCssConfiguration = getColorVariantCssConfiguration;
/**
 * Gets the CSS variable value for a color variant.
 *
 * @export
 * @param {ColorVariant} variant
 * @returns {string}
 */
function getColorVariantCssVariableValue(variant, config) {
    if (config.hexadecimal) {
        return variant.color.toHex8String();
    }
    else if (variant.color.a !== 1) {
        return `${variant.color.r},${variant.color.g},${variant.color.b},${variant.color.a}`;
    }
    else {
        return `${variant.color.r},${variant.color.g},${variant.color.b}`;
    }
}
exports.getColorVariantCssVariableValue = getColorVariantCssVariableValue;
/**
 * Gets the CSS value for an opacity variant.
 *
 * @export
 * @param {Color} color
 * @param {OpacityVariant} variant
 * @param {Configuration} config
 * @returns {string}
 */
function getOpacityVariantCssConfiguration(color, variant, config) {
    return `rgba(var(${getColorVariableName(color, config)}), var(${getOpacityVariantVariableName(variant)}))`;
}
exports.getOpacityVariantCssConfiguration = getOpacityVariantCssConfiguration;
/**
 * Gets the CSS value for a color.
 *
 * @export
 * @param {Color} color
 * @param {Configuration} config
 * @returns {string}
 */
function getColorCssConfiguration(color, config) {
    const variable = `var(${getColorVariableName(color, config)})`;
    if (config.hexadecimal) {
        return variable;
    }
    else if (color.computed.a !== 1) {
        return `rgba(${variable}, ${color.computed.a})`;
    }
    else {
        return `rgb(${variable})`;
    }
}
exports.getColorCssConfiguration = getColorCssConfiguration;
/**
 * Gets the CSS variable value for a color.
 *
 * @export
 * @param {Color} color
 * @returns {string}
 */
function getColorCssVariableValue(color, config) {
    return config.hexadecimal ? color.computed.toHex8String() : `${color.computed.r},${color.computed.g},${color.computed.b}`;
}
exports.getColorCssVariableValue = getColorCssVariableValue;
/**
 * Gets the pascal case version of the string.
 *
 * @export
 * @param {string} str
 * @returns {string}
 */
function getPascalCase(str) {
    return str && (str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g) || []).map(x => x.toLowerCase()).join('-');
}
exports.getPascalCase = getPascalCase;
