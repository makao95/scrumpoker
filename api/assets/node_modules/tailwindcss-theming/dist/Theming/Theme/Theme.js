"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ThemeScheme_1 = require("./ThemeScheme");
const Color_1 = require("../Color/Color");
const parseColorObject_1 = require("../Parser/Color/parseColorObject");
const OpacityVariant_1 = require("../Variant/OpacityVariant");
const ColorVariant_1 = require("../Variant/ColorVariant");
const CustomProperty_1 = require("../CustomProperty/CustomProperty");
exports.DEFAULT_THEME_NAME = 'default';
class Theme {
    constructor() {
        this._assignable = false;
        this._colors = [];
        this._customProperties = [];
        this._variants = [];
    }
    /**
     * Sets this theme the default theme.
     *
     * @returns {this}
     * @memberof Theme
     */
    default() {
        this._default = true;
        this._name = this._name || exports.DEFAULT_THEME_NAME;
        return this;
    }
    /**
     * Defines if this theme must be assignable by strategy.
     *
     * @returns {this}
     * @memberof Theme
     */
    assignable() {
        this._assignable = true;
        return this;
    }
    /**
     * Sets the name of this theme.
     *
     * @param {string} [name]
     * @returns {(this | string)}
     * @memberof Theme
     */
    name(name) {
        this._name = name;
        return this;
    }
    /**
     * Defines this theme as a light theme.
     *
     * @returns {this}
     * @memberof Theme
     */
    light() {
        this._scheme = ThemeScheme_1.ThemeScheme.Light;
        return this;
    }
    /**
     * Defines this theme as a dark theme.
     *
     * @returns {this}
     * @memberof Theme
     */
    dark() {
        this._scheme = ThemeScheme_1.ThemeScheme.Dark;
        return this;
    }
    /**
     * Sets a variable on this theme.
     *
     * @param {string} name
     * @param {CustomPropertyValueType} value
     * @param {string} [extend]
     * @param {string|false} [prefix]
     * @param {boolean} [parse=true]
     * @returns {this}
     * @memberof Theme
     */
    customProperty(name, value, extend, prefix, parse = true) {
        this._customProperties.push(new CustomProperty_1.CustomProperty(name, value, extend, prefix, parse));
        return this;
    }
    /**
     * Sets a variable on this theme.
     *
     * @param {string} name
     * @param {CustomPropertyValueType} value
     * @param {string} [extend]
     * @param {string|false} [prefix]
     * @param {boolean} [parse=true]
     * @returns {this}
     * @memberof Theme
     */
    variable(name, value, extend, prefix, parse = true) {
        return this.customProperty(name, value, extend, prefix, parse);
    }
    /**
     * Sets a color on this theme.
     *
     * @param {string} name
     * @param {string} value
     * @returns {this}
     * @memberof Theme
     */
    color(name, value) {
        this._colors.push(new Color_1.Color().name(name).value(value));
        return this;
    }
    /**
     * Sets the colors of this theme.
     *
     * @param {(Colors | Color[])} colors
     * @returns {(this | string)}
     * @memberof Theme
     */
    colors(colors) {
        if (Array.isArray(colors)) {
            this._colors = colors;
        }
        else {
            this._colors = parseColorObject_1.parseColorObject(colors);
        }
        return this;
    }
    /**
     * Adds an opacity variant.
     *
     * @param {string} name Name of the variant.
     * @param {number} value Value of the variant.
     * @param {string[]} [colors] The color keys to be associated to. If empty, this will be a general variant.
     * @returns {this}
     * @memberof Theme
     */
    opacityVariant(name, value, colors) {
        this.checkVariantUniqueness(name, colors, true);
        this._variants.push(new OpacityVariant_1.OpacityVariant(name, value, !colors ? [] : Array.isArray(colors) ? colors : [colors]));
        return this;
    }
    /**
     * Adds a color variant.
     *
     * @param {string} name Name of the variant.
     * @param {number} value Value of the variant.
     * @param {string[]} [colors] The color keys to be associated to. If empty, this will be a general variant.
     * @returns {this}
     * @memberof Theme
     */
    colorVariant(name, value, colors) {
        this.checkVariantUniqueness(name, colors, true);
        this._variants.push(new ColorVariant_1.ColorVariant(name, value, !colors ? [] : Array.isArray(colors) ? colors : [colors]));
        return this;
    }
    /**
     * Checks if a variant exists on this theme.
     *
     * @param {string} name Variant name.
     * @param {boolean} [throws=false] Throws an error if the variant exists.
     * @throws If `throws` is set to `true` and the variant exists.
     * @returns {boolean}
     * @memberof Theme
     */
    hasVariant(name, throws = false) {
        let exists = this._variants.find(v => v.name === name);
        if (exists && throws) {
            throw new Error(`Variant ${name} already exists.`);
        }
        return !!exists;
    }
    /**
     * Checks if a variant exists for a color on this theme.
     *
     * @param {string} name Variant name.
     * @param {(string[] | string)} [colors] Colors.
     * @param {boolean} [throws=false] Throws an exception.
     * @returns {boolean}
     * @memberof Theme
     */
    checkVariantUniqueness(name, colors, throws = false) {
        if (typeof colors === 'string' || (Array.isArray(colors) && 1 === colors.length)) {
            let color = Array.isArray(colors) ? colors[0] : colors;
            let exists = this._variants.find(v => v.name === name && v.colors.length === 1 && v.colors[0] === color);
            if (exists && throws) {
                throw new Error(`Variant ${name} already exists for the color '${color}'.`);
            }
            return !!exists;
        }
        return this.hasVariant(name, true);
    }
    /**
     * Gets the variants of the given color.
     *
     * @param {string} color
     * @returns {Variant[]}
     * @memberof Theme
     */
    variantsOf(color) {
        return this._variants.filter(variant => variant.colors.includes(color) || 0 === variant.colors.length);
    }
    /**
     * Checks if this theme is set as the default theme.
     *
     * @returns {boolean}
     * @memberof Theme
     */
    isDefault() {
        return this._default;
    }
    /**
     * Returns this theme's name.
     *
     * @returns {string}
     * @memberof Theme
     */
    getName() {
        return this._name || null;
    }
    /**
     * Returns this theme's colors.
     *
     * @returns {Color[]}
     * @memberof Theme
     */
    getColors() {
        return this._colors;
    }
    /**
     * Return this theme's custom properties.
     *
     * @returns {CustomProperty[]}
     * @memberof Theme
     */
    getCustomProperties() {
        return this._customProperties;
    }
    /**
     * Gets this theme's scheme.
     *
     * @returns {ThemeScheme}
     * @memberof Theme
     */
    getScheme() {
        return this._scheme || null;
    }
    /**
     * Gets if this theme has a defined name.
     *
     * @readonly
     * @type {boolean}
     * @memberof Theme
     */
    hasName() {
        return undefined !== this._name && this._name.length > 0;
    }
    /**
     * Gets if this theme must be assignable by strategy.
     *
     * @readonly
     * @type {boolean}
     * @memberof Theme
     */
    isAssignable() {
        return this._assignable;
    }
    /**
     * Checks if this theme has a color scheme.
     *
     * @readonly
     * @type {boolean}
     * @memberof Theme
     */
    hasScheme() {
        return undefined !== this._scheme;
    }
}
exports.Theme = Theme;
